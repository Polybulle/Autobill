open Vars
open Types
open Constructors
open Ast
open Format


module type PP_Delegate = sig
  val pp_utyp : formatter -> utyp -> unit
  val pp_usort : formatter -> usort -> unit
  val pp_upol : formatter -> upol -> unit
  val usort_pos_sort : usort
  val usort_neg_sort : usort
end

module AstPrettyPrinter (Del : PP_Delegate) = struct

  open Del

  let pp_comma_sep fmt () =
    fprintf fmt ",@ "

  let pp_var fmt v = pp_print_string fmt (Var.to_string v)

  let pp_tvar fmt v = pp_print_string fmt (TyVar.to_string v)

  let pp_cvar fmt v = pp_print_string fmt (ConsVar.to_string v)

  let pp_dvar fmt v = pp_print_string fmt (DestrVar.to_string v)

  let pp_defvar fmt v = pp_print_string fmt (DefVar.to_string v)

  let rec pp_typ fmt t =
    match t with
    | TPos t -> fprintf fmt "+%a" pp_typ t
    | TNeg t -> fprintf fmt "-%a" pp_typ t
    | TVar v -> pp_tvar fmt v.node
    | TInternal v -> fprintf fmt "<%a>" pp_tvar v
    | TBox b -> fprintf fmt "@[<hov 2>(%s@ %a)@]" (string_of_box_kind b.kind) pp_typ b.node
    | TCons c -> match c.node with
      | Unit -> pp_print_string fmt "unit"
      | Zero -> pp_print_string fmt "zero"
      | Top -> pp_print_string fmt "top"
      | Bottom -> pp_print_string fmt "bottom"
      | Prod (a,b) -> fprintf fmt "@[<hov 2>(prod@ %a@ %a)@]" pp_typ a pp_typ b
      | Sum (a,b) -> fprintf fmt "@[<hov 2>(sum@ %a@ %a)@]" pp_typ a pp_typ b
      | Fun (a,b) -> fprintf fmt "@[<hov 2>(fun@ %a@ %a)@]" pp_typ a pp_typ b
      | Choice (a,b) -> fprintf fmt "@[<hov 2>(choice@ %a@ %a)@]" pp_typ a pp_typ b
      | Cons (c,args) ->
        fprintf fmt "@[<hov 2>(%a@ %a)@]"
          pp_tvar c
          (pp_print_list ~pp_sep:pp_print_space pp_typ) args

  let pp_constructor pp_k fmt cons =
    match cons with
    | Unit -> pp_print_string fmt "unit()"
    | Pair (a,b) -> fprintf fmt "@[<hov 2>pair(@,%a,@ %a)@]" pp_k a pp_k b
    | Left x -> fprintf fmt "left(%a)" pp_k x
    | Right x -> fprintf fmt "right(%a)" pp_k x
    | PosCons (c, args) ->
      fprintf fmt ":%a(@[<hov 2>%a@])"
        pp_cvar c
        (pp_print_list ~pp_sep:pp_comma_sep pp_k) args

  let pp_destructor pp_k pp_ka fmt destr =
    match destr with
    | Call (x,a) -> fprintf fmt ".call(%a)%a" pp_k x pp_ka a
    | Yes a -> fprintf fmt ".yes()%a" pp_ka a
    | No a -> fprintf fmt ".no()%a" pp_ka a
    | NegCons (c, args, a) ->
      fprintf fmt ".%a(@[<hov 2>%a@])%a"
        pp_dvar c
        (pp_print_list ~pp_sep:pp_comma_sep pp_k) args
        pp_ka a


  let pp_custom_binding ~prefix ~suffix fmt pp_v v pp_t t =
    fprintf fmt "@[<hov 2>%s%a@ : %a%s@]" prefix pp_v v pp_t t suffix

  let pp_bind fmt (v, t) =
    pp_custom_binding ~prefix:"" ~suffix:"" fmt pp_var v pp_utyp t

  let pp_bind_def fmt (v, t) =
    pp_custom_binding ~prefix:"" ~suffix:"" fmt pp_defvar v pp_utyp t

  let pp_bind_def_with_cont fmt (v, t, cont) =
    pp_custom_binding ~prefix:"" ~suffix:"" fmt pp_defvar v pp_utyp t;
    fprintf fmt "@ returns %a" pp_utyp cont

  let pp_bind_paren fmt (v, t) =
    pp_custom_binding ~prefix:"(" ~suffix:")" fmt pp_var v pp_utyp t

  let pp_bind_copatt fmt t =
    pp_custom_binding ~prefix:"" ~suffix:"" fmt pp_print_string ".ret()" pp_utyp t

  let pp_bind_bindcc fmt t =
    fprintf fmt " @[<hov 2>(ret()@ : %a)@]" pp_utyp t

  let pp_bind_typ_paren fmt (t, so) =
    pp_custom_binding  ~prefix:"(" ~suffix:")" fmt pp_tvar t pp_usort so


  let pp_pattern fmt p =
    pp_constructor pp_bind fmt p

  let pp_copattern fmt p =
    pp_destructor pp_bind pp_bind_copatt fmt p

  let pp_pol_annot fmt pol = pp_upol fmt pol


  let rec pp_value fmt = function
    | MetaVal {node; _} -> pp_pre_value fmt node


  and pp_pre_value fmt = function

    | Var v -> pp_var fmt v

    | Bindcc {po; bind=typ; cmd; _} ->
      fprintf fmt "@[<hov 2>bind/cc%a%a ->@ %a@]"
        pp_pol_annot po
        pp_bind_bindcc typ
        pp_cmd cmd

    | Box {kind; bind=typ; cmd; _} ->
      fprintf fmt "@[<hov 2>box(%a)%a ->@ %a@]"
        pp_print_string (string_of_box_kind kind)
        pp_bind_bindcc typ
        pp_cmd cmd

    | Cons c -> pp_constructor pp_value fmt c

    | Destr patts ->
      let pp_case fmt (p,c) =
        fprintf fmt "@[<hov 2>case this%a ->@ %a@]" pp_copattern p pp_cmd c in
      fprintf fmt "@[<v 0>@[<v 2>match@,%a@]@,end@]"
        (pp_print_list ~pp_sep:pp_print_space pp_case) patts

  and pp_stack fmt (MetaStack s) = pp_pre_stack fmt s.node

  and pp_pre_stack fmt s =
    pp_print_string fmt "this";
    pp_open_hbox fmt ();
    pp_pre_stack_trail fmt s;
    pp_close_box fmt ()

  and pp_stack_trail fmt (MetaStack s) = pp_pre_stack_trail fmt s.node

  and pp_pre_stack_trail fmt s =
    match s with

    | Ret -> fprintf fmt "@,.ret()"

    | CoBind {po; bind = (name, typ); cmd; _} ->
      fprintf fmt "@,@[<hov 2>.bind%a %a ->@ %a@]"
        pp_pol_annot po
        pp_bind_paren (name, typ)
        pp_cmd cmd

    | CoBox {kind; stk; _} ->
      fprintf fmt "@,.unbox(%a)%a"
        pp_print_string (string_of_box_kind kind)
        pp_stack_trail stk

    | CoDestr d ->
      pp_print_cut fmt ();
      pp_destructor pp_value pp_stack_trail fmt d

    | CoCons patts ->
      let pp_case fmt (p,c) =
        fprintf fmt "@[<hov 2>case %a ->@ %a@]" pp_pattern p pp_cmd c in
      fprintf fmt "@[<v 0>@[<v 2>.match@,%a@]@,end@]"
        (pp_print_list ~pp_sep:pp_print_space pp_case) patts

  and pp_cmd fmt cmd =
    let Command {po; valu; mid_typ; stk; _} = cmd in
    let pp_annot fmt typ =
      fprintf fmt "@ : %a" pp_utyp typ in
    let MetaVal {node = pre_valu; _} = valu in
    match pre_valu with
    | Var _ | Cons _ ->
      fprintf fmt "%a%a"
        pp_value valu
        pp_stack_trail stk
    | _ ->
      fprintf fmt "@[<v 0>step%a@;<1 2>%a%a@ into@;<1 2>%a@ end@]"
        pp_pol_annot po
        pp_value valu
        pp_annot mid_typ
        pp_stack stk

  let pp_typ_lhs fmt (name, args, sort) =
    if args = [] then
      pp_tvar fmt name
    else
      fprintf fmt "@[<hov 2>%a %a@]"
        pp_tvar name
        (pp_print_list ~pp_sep:pp_print_space pp_bind_typ_paren) args;
    fprintf fmt " : %a" pp_usort sort

  let pp_data_decl_item fmt item =
    match item with
    | PosCons (name, args) ->
      fprintf fmt "@[<hov 2>case :%a(%a)@]"
        pp_cvar name
        (pp_print_list ~pp_sep:pp_comma_sep pp_typ) args
    | _ -> failwith ("Some constructor has a reserved name in a data definition")

  let pp_codata_decl_item fmt item =
    match item with
    | NegCons (name, args, cont) ->
      fprintf fmt "@[<hov 2>case this.%a(%a).ret() : %a@]"
        pp_dvar name
        (pp_print_list ~pp_sep:pp_comma_sep pp_typ) args
        pp_typ cont
    | _ -> failwith ("Some constructor has a reserved name in a data definition")


  let pp_prelude_def fmt def =
    let Prelude_def {name; sort; args; def; _} = def in
    match def with
    | Type_declaration ->
      fprintf fmt "decl type %a : %a"
        pp_tvar name
        pp_usort sort
    | Type_definition content ->
      fprintf fmt "type %a =@ %a" pp_typ_lhs (name, args, sort) pp_typ content

    | Data_definition content ->
      fprintf fmt "@[<v 2>data %a =@,%a@]"
        pp_typ_lhs (name, args, usort_pos_sort)
        (pp_print_list ~pp_sep:pp_print_cut pp_data_decl_item) content

    | Codata_definition content ->
      fprintf fmt "@[<v 2>codata %a =@,%a@]"
        pp_typ_lhs (name, args, usort_neg_sort)
        (pp_print_list ~pp_sep:pp_print_cut pp_codata_decl_item) content

  let pp_definition fmt def =
    let Definition {name; typ; cont; content; _} = def in
    pp_open_box fmt 2;
    begin
      match content with
      | Value_definition content ->
        fprintf fmt "term %a =@ %a"
          pp_bind_def (name, typ)
          pp_value content

      | Stack_definition content ->
        fprintf fmt "env %a =@ %a"
          pp_bind_def_with_cont (name, typ, cont)
          pp_stack content

      | Command_definition content ->
        fprintf fmt "cmd %a =@ %a"
          pp_bind_def_with_cont (name, typ, cont)
          pp_cmd content
    end;
    pp_close_box fmt ()

  let pp_program fmt (prelude, prog) =
    let pp_double_cut fmt () = pp_print_cut fmt (); pp_print_cut fmt () in
    pp_open_vbox fmt 0;
    pp_print_list ~pp_sep:pp_double_cut pp_prelude_def fmt prelude;
    pp_double_cut fmt ();
    pp_print_list ~pp_sep:pp_double_cut pp_definition fmt prog;
    pp_close_box fmt ()

end
