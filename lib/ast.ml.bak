open Types
open Vars
open Constructors
open Util

type utyp = int
type usort = int
type upol = int

module type UVarParam = sig
  type content
  val fresh : int -> content
end

module type IUVar = sig
  type t = int
  type content
  val fresh : unit -> t
  val from_content : content -> t
  val get : t -> content
end

module UVar (Param : UVarParam) = struct

  open Param

  module M = Map.Make (struct
    type t = int
    let compare = compare
  end)

  type t = int
  type content = Param.content

  let hacky_global_counter = ref 0
  let vars = ref M.empty

  let fresh () =
    let v = !hacky_global_counter in
    let s = fresh v in
    vars := M.add v s !vars;
    incr hacky_global_counter;
    v

  let from_content s =
    let v = !hacky_global_counter in
    vars := M.add v s !vars;
    incr hacky_global_counter;
    v

  let get v = M.find v !vars

end

module UPol = UVar (struct
    type content = upol pre_polarity
    let fresh v = PVar v
  end)

module USort = UVar (struct
    type content = (usort, upol) pre_sort
    let fresh n = SortVar n
  end)

module UTyp = UVar (struct
    type content = int pre_typ
    let fresh n = TInternal n
  end)

type val_bind = Var.t * utyp
type cont_bind = utyp

type pattern = (val_bind) constructor
type copattern = (val_bind, cont_bind) destructor

type meta_value = MetaVal of {
  node : pre_value;
  val_typ : utyp;
  loc : position
}

and pre_value =
  | Var of Var.t
  | Bindcc of {
      bind : cont_bind;
      po : upol;
      cmd : command}
  | Box of {
      kind : box_kind;
      bind : cont_bind;
      cmd : command}
  | Cons of meta_value constructor
  | Destr of (copattern * command) list

and meta_stack = MetaStack of {
  node : pre_stack;
  cont_typ : utyp;
  final_typ : utyp;
  loc : position}

and pre_stack =
  | Ret
  | CoBind of {
      bind : val_bind;
      po : upol;
      cmd : command}
  | CoBox of {
      kind : box_kind;
      stk : meta_stack}
  | CoDestr of (meta_value, meta_stack) destructor
  | CoCons of (pattern * command) list

and command = Command of {
    po : upol;
    valu : meta_value;
    stk : meta_stack;
    mid_typ : utyp;
    loc : position}

type prelude_def = Prelude_def of {
    name : TyVar.t;
    sort : usort;
    args : (TyVar.t * usort) list;
    loc : Util.position;
    def : prelude_content}

and prelude_content =
  | Type_declaration
  | Type_definition of typ
  | Data_definition of (typ constructor) list
  | Codata_definition of ((typ,typ) destructor) list

type definition = Definition of {
      name : DefVar.t;
      typ : utyp;
      sort : usort;
      cont : cont_bind;
      content : content;
      loc : position
    }

and content =
  | Value_definition of meta_value
  | Stack_definition of meta_stack
  | Command_definition of command

type program = prelude_content list * definition list

let defined_constructors_destructors prelude =
  let conses = ref [] in
  let destrs = ref [] in
  let add xs x = (xs := x :: !xs) in
  let process_one = function
    | Data_definition def ->
      List.iter (Option.iter (add conses)) (List.map consvar_of_constructor def)
    | Codata_definition def ->
      List.iter (Option.iter (add destrs)) (List.map destrvar_of_destructor def)
    | _ -> () in
  List.iter process_one prelude;
  (!conses, !destrs)

let dummy_val_meta v = MetaVal {
      node = v;
      loc = Util.dummy_pos;
      val_typ = UTyp.fresh ()
    }

  let dummy_stack_meta s = MetaStack {
      node = s;
      loc = Util.dummy_pos;
      cont_typ = UTyp.fresh ();
      final_typ  = UTyp.fresh ();
    }

  module V = struct
    type t = meta_value
    let var x = dummy_val_meta (Var x)
    let bindcc po bind cmd = dummy_val_meta (Bindcc {po;cmd;bind})
    let box kind bind cmd = dummy_val_meta (Box {kind; bind; cmd})
    let cons c = dummy_val_meta (Cons c)
    let case l = dummy_val_meta (Destr l)
  end

  module S = struct
    type t = meta_stack
    let ret = dummy_stack_meta (Ret)
    let bind po bind cmd = dummy_stack_meta (CoBind {po; bind; cmd})
    let box kind stk = dummy_stack_meta (CoBox {kind; stk})
    let destr c = dummy_stack_meta (CoDestr c)
    let case l = dummy_stack_meta (CoCons l)
  end
