decl type test : (+)
decl type test : (-)
type test : (+) = tvar
type test a b c d : (+) = tvar
type test : (+) = box(lin) (box(aff) (box(exp) tvar))
type test a = prod unit (sum zero (choice top (fun bottom a))

data test =
  | test(unit)

codata test a b =
  | this.mycall(a).cont(b)

codata test a b =
  | this.myyes().cont(a)
  | this.myno().cont(b)

cmd test = v.s
cmd test = step(pol) v into s
cmd test = step(pol) into s with v

term test : t = x
term test = pair(left(unit), right(x))
term test = mycons
term test = mycons(x, y, z)

term test = box(kind) (ret() : t) -> cmd
term test = box(kind) -> cmd

term test = bind/cc(pol) (ret() : top) -> cmd
term test = bind/cc -> cmd

term test = match this.cons(x : t, y : u, z : v).ret() : w -> cmd
term test = match
  | this.cons1(x : t, y : u, z : v).ret() : w -> cmd
  | this.cons2(x : t, y : u, z : v).ret() : w -> cmd
  end

env !test : t = this.ret()
env !test = this.call(x).yes().no().ret()
env !test = this.mycons.ret()
env !test = this.mycons2(x, y, z).ret()

env !test = this.unbox(lin).ret()

env test = bind(pol) (x : t) -> cmd
env test = bind x -> cmd

env test = match cons(x : t, y : u, z : v) -> cmd
env test = match
  | cons1(x : t, y : u, z : v) -> cmd
  | cons2(x : t, y : u, z : v) -> cmd
  end


term test = fun (x : t) -> v
term test = match this.call(x).ret() -> step(~) v into ret()

term test = box(lin) v
term test = box(lin) -> step(~) v ret()

cmd test = term :cons(x,y,z) = v in cmd
cmd test = step(+) with u to match cons(x,y,z) -> cmd

cmd test = env this.cons(x,y,z).ret() in cmd
cmd test = step(-) to ret() with match this.cons(x,y,z).ret() -> cmd

cmd test = term x = v in cmd
cmd test = step with v to bind(~) (x : t) -> cmd

cmd test = env s in cmd
cmd test = step to s with bind/cc(~) (ret() : t) -> cmd

term id =
  match this.call(x).ret() -> jump x ret()
