decl type test : +
decl type test : -
type test : + = tvar
type test (a : +) (b : -) (c : -) (d : +) : + = (d e (f g h))
type test : + = (exp (aff (lin a)))
type test (a : -) : + = (prod unit (sum zero (choice top (fun bottom a))))
data test =
  case :test(unit)
codata test (a : +) (b : -) =
  case this.mycall(a).ret() : b
codata test (a : +) (b : -) =
  case this.myyes().ret() : a
  case this.myno().ret() : b
cmd test = step+ v into this.ret() end
cmd test = v.ret()
cmd test = step into this.ret() with v end
term test : t = x
term test = :mycons()
term test = :mycons(x, y, z)
term test = tupple(left(unit()), right(inj(1/3,unit())))
term test = box(exp) (ret() : t) -> v.ret()
term test = box(exp) -> v.ret()
term test = bind/cc+ (ret() : t) -> v.ret()
term test = bind/cc -> v.ret()
term test = match this.cons(x, y, z).ret()-> v.ret()
term test = match this.cons(x : t, y : u, z : v).ret() : w -> v.ret()
term test = match
  case this.cons1(x : t, y : u, z : v).ret() : w -> v.ret()
  case this.cons2(x : t, y : u, z : v).ret() : w -> v.ret()
end
cmd test : t = step unit() into this.ret() end
cmd test = step unit() into this.call(x).yes().no().proj(1/3).ret() end
cmd test = step unit() into this.mycons().ret() end
cmd test = step unit() into this.mycons2(x, y, z).ret() end
cmd test = step unit() into this.unbox(lin).ret() end
cmd test = step unit() into this.bind x -> v.ret() end
cmd test = step unit() into this.bind+ (x : t) -> v.ret() end
cmd test = step unit() into this.match :cons(x, y, z) -> v.ret() end
cmd test = step unit() into this.match
  case :cons1(x : t, y : u, z : v) -> v.ret()
  case :cons2(x : t, y : u, z : v) -> v.ret()
end
end
term test = fun (x : t) -> v
term test = box(lin) v
cmd test = match :cons(x,y,z) = v in v.ret()
cmd test = match env this.cons(x,y,z).ret() in v.ret()
cmd test = term x = v in v.ret()
cmd test = env this.ret() in v.ret()
