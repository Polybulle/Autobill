prog:
  <empty>
  <toplevel> <prog>

toplevel:
  decl sort sortvar
  decl type tvar :: <scheme>
  decl rel relvar :: sortvar * ...
  type tvar :: <scheme> = <typ>
  data tvar (tvar :: <sort>) ... = <consdef>
  comput tvar (tvar :: <sort>)... = <destrdef>
  decl x : <typ> :: <sort>
  def x : <typ> :: <sort> = <val>
  cmd <cmd>

consdef:
  | Cons< tvar::<sort>, ...>( <typ>, ...) where [ <rel>, ...]

destrdef:
  | Cons< tvar::<sort>, ...>(<typ>, ...) ~> typ where [ <rel>, ...]

<rel>:
  Relvar( <typ>, ...)
  <typ> = <typ>

cmd:
  ret <val> @ <stk>
  do <instr>;... end
S case <val> of <pat> -> <cmd> | ... end
S recv <stk> as <stk_pat> -> <cmd> | ... end

<instr>:
  <cmd>
  val x : <typ> :: <sort> = <val>
  stk a : <typ> ~> <typ> :: <sort> ~> <sort> = <stk>
S case <val> of <pat>
S recv <stk> as <stk_pat>

<val>:
  x
  (<val> : <typ> :: <sort>)
  with @ (a : <typ> ~> :: <sort> ~> <sort>) <cmd>
  Cons< <typ>, ...>(<val>, ...)
S ()
S (<val>, ...)
S inj_n_m(val)
S pack< <typ> : <sort>, ...>(<val>)
S witness[<rel> ...](<val>)
  share @ a : <typ> :: <sort> -> <cmd>
S share(<val>)
  closure @ a : <typ> :: <sort> -> <cmd>
S closure(<val>)
  thunk <val>
  fix(x : <typ> :: <sort>) @ (a : <typ> ~> <typ> :: <sort> ~> <sort>) -> <cmd>
S fix(x : <typ> :: <sort>) -> <val>
  recv | <stk_pat> -> <cmd> | ... end
  absurd

<stk_pat>:
  a
  (<stk_pat> : <typ> ~> <typ> :: <sort> ~> <sort>)
  <stk_pat_head> ~> <stk_pat>

<stk_pat_head>:
  Cons<tvar, ...>(<pat>, ...)
S call(<pat>, <pat>, ...)
S proj_n_m
S spec<tvar::<sort>, ...>
S assert[ rel ]

<stk>:
  a
  (<stk> : <typ> ~> <typ> :: <sort> ~> <sort>)
  with (x : <typ> ~> <typ> : <sort> ~> <sort>) <cmd>
  case | <pat> -> <cmd> | ... end
  force (x : <typ> :: <sort>) -> <cmd>
  <stk_head> ~> <stk>
  absurd

<stk_head>:
  share
  enter
  fix
  Cons< <typ>, ...>(<val>, ...)
S force~><stk>
S call(<val>, ...)
S proj_n_m
S spec< <typ>, ...>
S assert[<rel>, ...]

<pat>:
  x
  (<pat> : <typ> :: <sort>)
  Cons<tvar :: <sort>, ...>(<pat>, ...)
S ()
S (<pat>, ...)
S inj_n_m(pat)
S pack< tvar :: <sort>, ...>(<pat>)
S witness[<rel>, ...](<pat>)


<typ>:
  tvar
  \tvar... -> <typ>
  (<typ> <typ>...)
  /\ <typ>
  \/ <typ>
  forall tvar... . <typ>
  exists tvar... . <typ>
  [<rel>...] => <typ>
  [<rel>...] && <typ>
S (<typ>, <typ>, ...)
S (<typ> + <typ> + ...)
S (<typ> & <typ> & ...)
S (<typ> -> <typ> -> ... -> <typ>)
S unit zero top bottom

<scheme>:
  <sort>
  <sort> -> <scheme>

<sort>:
  +
  -
  <isort>

<isort>:
  sortvar
  <isort> -> <isort>

################

def id : forall t. t -> /\t =
  recv (spec<u> ~> call(x:u) ~> b) ->
    ret thunk(x) @ b
